import os
import json
import numpy as np
from PIL import Image
from tqdm import tqdm
import pycocotools.mask as mask_util

def load_instances(isaid_dir, split):
    """Load instance annotations for a specific split"""
    instances_file = os.path.join(isaid_dir, split, 'Annotations', f'instances_{split}.json')
    with open(instances_file, 'r') as f:
        instances = json.load(f)
    return instances

def count_patches_with_objects(image_path, image_id, instances, patch_size, overlap):
    """Count patches that would be generated by create_patches.py"""
    try:
        # Get image dimensions without loading full image data
        with Image.open(image_path) as img:
            width, height = img.size
    except Exception as e:
        print(f"Error opening {image_path}: {e}")
        return 0, (0, 0), (0, 0), 0, 0
    
    # Ensure the image is large enough to patch
    if width < patch_size or height < patch_size:
        return 0, (width, height), (0, 0), 0, 0
    
    # Calculate step size based on overlap
    step_size = int(patch_size * (1 - overlap))
    step_size = max(1, step_size)  # Ensure step size is at least 1
    
    # Calculate number of possible patches
    num_patches_x = 1 + (width - patch_size) // step_size
    num_patches_y = 1 + (height - patch_size) // step_size
    total_possible_patches = num_patches_x * num_patches_y
    
    # Count patches with objects
    patches_with_objects = 0
    patches_without_objects = 0
    
    # Generate all possible patches with the sliding window
    for y in range(0, height - patch_size + 1, step_size):
        for x in range(0, width - patch_size + 1, step_size):
            has_valid_object = False
            
            for ann in instances['annotations']:
                if ann['image_id'] != image_id:
                    continue
                
                # Get the original bbox
                bbox = ann['bbox']
                bbox_x, bbox_y, bbox_w, bbox_h = bbox
                
                # Check if the object intersects with the patch
                if (bbox_x + bbox_w > x and bbox_x < x + patch_size and 
                    bbox_y + bbox_h > y and bbox_y < y + patch_size):
                    
                    # Calculate the intersection area
                    intersection_x1 = max(bbox_x, x)
                    intersection_y1 = max(bbox_y, y)
                    intersection_x2 = min(bbox_x + bbox_w, x + patch_size)
                    intersection_y2 = min(bbox_y + bbox_h, y + patch_size)
                    
                    intersection_width = max(0, intersection_x2 - intersection_x1)
                    intersection_height = max(0, intersection_y2 - intersection_y1)
                    intersection_area = intersection_width * intersection_height
                    
                    # Calculate the original bbox area
                    original_area = bbox_w * bbox_h
                    
                    # Check if at least 50% of the bbox is in the patch
                    if intersection_area / original_area >= 0.5:
                        has_valid_object = True
                        break
            
            if has_valid_object:
                patches_with_objects += 1
            else:
                patches_without_objects += 1
    
    return patches_with_objects, (width, height), (num_patches_x, num_patches_y), total_possible_patches, patches_without_objects

def main(isaid_dir):
    # Use the same parameters as in create_patches.py
    patch_size = 480
    window_overlap = 0.2
    splits = ['train', 'val']
    
    # Dictionary to store image paths and their IDs
    image_info = []
    
    # Collect all image paths and IDs
    for split in splits:
        images_dir = os.path.join(isaid_dir, split, 'images', 'images')
        if not os.path.exists(images_dir):
            print(f"Warning: {images_dir} does not exist")
            continue
        
        # Load instances for this split
        instances = load_instances(isaid_dir, split)
        
        print(f"Finding images in {split} split...")
        for img in instances['images']:
            filename = img['file_name']
            if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.tif', '.tiff')):
                image_info.append({
                    'path': os.path.join(images_dir, filename),
                    'id': img['id'],
                    'split': split,
                    'instances': instances
                })
    
    print(f"Total images found: {len(image_info)}")
    print(f"Patch size: {patch_size}x{patch_size}, overlap: {window_overlap*100:.1f}%")
    print(f"Step size: {int(patch_size * (1 - window_overlap))} pixels")
    print("\n{:<30} {:<15} {:<15} {:<15}".format(
        "Image Name", "Total Patches", "No Objects", "Valid Patches"))
    print("-" * 75)
    
    # Count patches for each image
    total_patches = 0
    total_possible = 0
    total_no_objects = 0
    patches_per_image = {}
    failed_images = 0
    
    for info in image_info:
        image_path = info['path']
        image_name = os.path.basename(image_path)
        
        # Count patches for this image
        image_patches, dimensions, patch_dims, possible_patches, no_objects = count_patches_with_objects(
            image_path, info['id'], info['instances'], patch_size, window_overlap)
        
        # Print information for each image
        print(f"{image_name:<30} {possible_patches:<15} {no_objects:<15} {image_patches:<15}")
        
        if image_patches > 0:
            patches_per_image[image_name] = image_patches
            total_patches += image_patches
            total_possible += possible_patches
            total_no_objects += no_objects
        else:
            failed_images += 1
    
    print("\n=== Patch Statistics ===")
    print(f"Total possible patches: {total_possible}")
    print(f"Patches without objects: {total_no_objects}")
    print(f"Valid patches with objects: {total_patches}")
    print(f"Failed to process images: {failed_images}")
    print(f"Patch size: {patch_size}x{patch_size}")
    print(f"Window overlap: {window_overlap * 100:.1f}%")
    
    print("\n=== Images with Most Patches ===")
    top_images = sorted([(k, v) for k, v in patches_per_image.items()], key=lambda x: x[1], reverse=True)[:10]
    for img_name, count in top_images:
        print(f"{img_name}: {count} patches")
    
    print(f"\nWith a limit of 50 patches (as in create_patches.py), you'll get exactly 50 patches.")
    print(f"Without any limit, you could generate up to {total_patches} patches with objects.")

if __name__ == '__main__':
    isaid_dir = "./isaid"  # Replace with your iSAID dataset path
    main(isaid_dir) 